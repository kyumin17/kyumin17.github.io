---
title: var, let, const의 차이
date: 2025-02-07 17:17:00 +/-0900
tags: [javascript]
author: Kyumin
math: true
---

### **재선언과 재할당**
재선언과 재할당이란 말 그대로 선언을 다시 하거나 할당을 다시 하는 것을 의미한다.

**재선언**
```javascript
var x = 1;
var x = 2;
```
**재할당**
```javascript
var x = 1;
x = 2;
```

#### **var**
var은 재선언, 재할당이 모두 가능하다. 위 두 코드를 실행해보면 모두 오류 없이 정상적으로 실행되는 것을 볼 수 있을 것이다.

#### **let**
반면, let은 재할당은 가능하나 재선언이 불가하다.
```javascript
let x = 1;
x = 2;
```
이 코드는 돌아가지만,
```javascript
let x = 1;
let x = 2;
```
이 코드는 오류가 난다.

#### **const**
const의 경우 재할당과 재선언 모두 불가하다.
```javascript
const x = 1;
const x = 2;
```
이 코드와
```javascript
const x = 1;
x = 2;
```
이 코드 모두 오류가 난다.

### **함수 스코프와 블록 스코프**
var은 함수 스코프를 가지고 let과 const는 블록 스코프를 가진다. 무슨 뜻일까?
#### **var**
```javascript
function func() {
  var x = 1;
  console.log(x);
}
```
var로 선언된 변수는 함수 안 어디에서든 접근 할 수 있다. 함수안에서 선언된 변수는 함수 안이라면 어디서든 참조할 수 있기 때문에 이를 보고 함수 스코프를 가진다고 한다.

따라서 이러한 코드도 작동한다.
```javascript
function func() {
  for (var i = 0; i < 5; i++) {
    
  }
  console.log(i);
}
```
위 코드는 오류를 뱉지 않고 5가 출력된다. var가 for문 안에서 선언되었다 하더라도 함수 안이며, i를 호출하여 출력한 것도 함수 안에서이기 때문에 정상적으로 동작하는 것이다.

단, 이러한 코드는 동작하지 않는다.
```javascript
function func() {
  var x = 1;
}
console.log(x);
```
x가 함수 안에서 선언되었으나 함수 밖에서 호출하려 하고 있으므로 오류가 뜬다.

#### **let, const**
위에서 var가 함수 안에서 선언되었으면 함수 안에서 참조할 수 있었듯, let과 const는 블록 안에서 선언되었으면 블록 안에서 참조할 수 있다. 이때 중괄호로 묶여있는 범위를 블록이라 보면 된다.
```javascript
function func() {
  for (let i = 0; i < 5; i++) {
    
  }
  console.log(i);
}
```
따라서 var의 예시와는 달리 위 코드가 동작하지 않는다. for문이 하나의 블록이기 때문에, 블록 밖에서 접근하려 하면 오류가 나는 것이다.
```javascript
function func() {
  let x = 1;
}
console.log(x);
```
당연히 위와 같은 코드도 동작하지 않는다. 함수 역시 하나의 블록이기 때문이다. 예시는 const일 때도 동일하다.

### **호이스팅과 TDZ**
var는 호이스팅이 되고, let과 const는 호이스팅이 되지 않는 것처럼 작동한다고 한다. 되지 않는 것도 아니고 되지 않는 것처럼 작동한다는 것은 뭘까?

먼저 변수가 생성될 때 선언, 초기화, 할당의 세 단계를 순차적으로 거친다.

선언 단계에서 변수는 변수 객체에 등록이 되며 초기화 단계에서 메모리가 할당되고 값이 undefined로 초기화된다. 할당 단계에서는 변수에 값이 들어간다.

그러나 이 세 단계는 한 번에 일어나지 않는다.

이것이 언제 일어나는지를 알기 위해서는 먼저 호이스팅을 알고 갈 필요가 있다. 호이스팅이란, 선언이 마치 선언된 스코프의 최상단으로 끌어 올려진 것처럼 작동하는 것을 말한다. 올려진 것처럼 작동한다고 말하는 이유는 실제로 끌어올려지는 것은 아니고, 코드가 실행되기 전에 자바스크립트 엔진에서 선언을 모두 메모리에 저장하는 것이기 때문이다.

이로 인해, 변수의 선언은 코드 실행 전에 일어나게 된다. 그렇다면 초기화와 할당은 언제 일어날까? var와 let, const를 나눠서 살펴볼 수 있다.

#### **var**
var에서는 호이스팅 시에 초기화도 같이 일어난다. 따라서 코드 실행 전에 선언과 초기화가 같이 일어나게 된다. 반면에 할당은 코드 실행 중에 일어난다.
```javascript
console.log(x);
var x = 1;
console.log(x);
```
위 코드는 먼저 실행 전에 변수 x가 선언되고, undefined로 초기화가 된다. 이후에 x를 출력하라 한다면 x에는 undefined가 들어가 있을 것이다. 이후에는 x가 1로 값이 할당되고, 이후에 x를 출력하라 하면 1이 출력된다. 따라서 출력은 다음과 같다.
```javascript
undefined
1
```

#### **let, const**
let과 const는 var와는 조금 다르게 동작한다. 둘은 호이스팅 시에 초기화가 일어나지 않으며, 코드 실행 중에 초기화와 할당이 일어난다.
```javascript
console.log(x);
let x = 1;
```
위 코드에서 변수 x가 실행 전에 먼저 선언될 것이다. 그런데 x에는 어떠한 값도 들어가지 않은 상태에서 출력을 하고 있다. 이렇게 되면 초기화 전에 x가 호출되었기 때문에 ReferenceError가 출력된다. 호이스팅은 일어났지만 초기화가 일어나지 않았기에 오류가 뜨기에 이것을 호이스팅이 되지 않은 것처럼 작동한다고 하는 것이다.

또한 이렇게 선언은 되었지만 아직 초기화되지 않은 상태를 TDZ(Temporal Dead Zone)이라 한다.

### **무엇을 쓸까**
그렇다면 세 가지 방법 중 무엇을 써야 할까?

일단 var은 쓰지 말자.

var에서는 다음과 같은 코드가 모두 돌아간다.
```javascript
var x = 1;
var x = 2;
```
```javascript
console.log(i);
for (var i = 0; i < 5; i++) {

}
console.log(i);
```
따라서 이전에 동일한 이름의 변수를 선언했다는 것을 까먹고 다시 선언하거나, 변수 선언 전에 호출해도 문제 없이 돌아간다. 실수를 잡아내기 어려워 질 뿐 아니라 제대로 돌아간다 하더라도 코드의 가독성이 저해된다. ES6에서 var의 단점을 보완하기 위해 내놓은 것이 let과 const이므로 웬만하면 let과 const를 쓰자.

재선언이 필요하다면 let을, 그렇지 않다면 const를 쓰자.
